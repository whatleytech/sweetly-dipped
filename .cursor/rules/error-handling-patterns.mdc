---
description: Standardize error handling patterns including error boundaries, user feedback, and error recovery
globs: ["src/**/*.{tsx,ts}", "**/*.test.{ts,tsx}"]
alwaysApply: true
---

# Error Handling Patterns

## Core Error Handling Principles

1. **Fail gracefully** - Never crash the entire application
2. **Provide clear feedback** - Users should understand what went wrong
3. **Enable recovery** - Always provide a path forward
4. **Log comprehensively** - Capture context for debugging
5. **Test error paths** - Error handling must be tested

## Error Boundary Implementation

### React Error Boundary Setup

```tsx
// src/components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log error to monitoring service
    console.error('ErrorBoundary caught an error:', error, errorInfo);
    
    // Call custom error handler
    this.props.onError?.(error, errorInfo);
    
    // Report to error tracking service
    this.reportError(error, errorInfo);
  }

  private reportError = (error: Error, errorInfo: ErrorInfo) => {
    // Example: Sentry, LogRocket, etc.
    // errorTrackingService.captureException(error, {
    //   contexts: { react: errorInfo }
    // });
  };

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <p>We're sorry, but something unexpected happened.</p>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### Error Boundary Placement Strategy

```tsx
// App.tsx - Wrap entire app
<ErrorBoundary onError={handleGlobalError}>
  <Router>
    <App />
  </Router>
</ErrorBoundary>

// Feature components - Wrap feature boundaries
<ErrorBoundary fallback={<FeatureErrorFallback />}>
  <UserDashboard />
</ErrorBoundary>

// Route components - Wrap individual routes
<ErrorBoundary fallback={<RouteErrorFallback />}>
  <UserProfile />
</ErrorBoundary>
```

### Error Boundary Testing

```tsx
// ErrorBoundary.test.tsx
import { render, screen } from '@testing-library/react';
import { ErrorBoundary } from './ErrorBoundary';

const ThrowError = ({ shouldThrow }: { shouldThrow: boolean }) => {
  if (shouldThrow) {
    throw new Error('Test error');
  }
  return <div>No error</div>;
};

describe('ErrorBoundary', () => {
  it('renders children when no error', () => {
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    );
    expect(screen.getByText('No error')).toBeInTheDocument();
  });

  it('renders fallback when error occurs', () => {
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
    
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );
    
    expect(screen.getByText('Something went wrong')).toBeInTheDocument();
    consoleSpy.mockRestore();
  });
});
```

## User Error Feedback Patterns

### Error Message Display Standards

```tsx
// src/components/ErrorMessage.tsx
interface ErrorMessageProps {
  error: string | Error;
  variant?: 'inline' | 'banner' | 'modal';
  onRetry?: () => void;
  onDismiss?: () => void;
}

export const ErrorMessage: React.FC<ErrorMessageProps> = ({
  error,
  variant = 'inline',
  onRetry,
  onDismiss
}) => {
  const message = typeof error === 'string' ? error : error.message;
  
  return (
    <div className={`error-message error-message--${variant}`} role="alert">
      <div className="error-message__content">
        <span className="error-message__icon">⚠️</span>
        <span className="error-message__text">{message}</span>
      </div>
      {onRetry && (
        <button 
          className="error-message__retry"
          onClick={onRetry}
          aria-label="Retry action"
        >
          Try Again
        </button>
      )}
      {onDismiss && (
        <button 
          className="error-message__dismiss"
          onClick={onDismiss}
          aria-label="Dismiss error"
        >
          ×
        </button>
      )}
    </div>
  );
};
```

### Error State Styling

```css
/* src/styles/error-states.css */
.error-message {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--spacing-md);
  background-color: var(--sd-pink-light);
  border: 1px solid var(--sd-pink-base);
  border-radius: var(--border-radius);
  color: var(--sd-brown-dark);
}

.error-message--banner {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.error-message--modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 1001;
  min-width: 300px;
  max-width: 500px;
}

.error-message__content {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.error-message__icon {
  font-size: 1.2em;
}

.error-message__retry,
.error-message__dismiss {
  background: var(--sd-pink-base);
  color: var(--sd-white);
  border: none;
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--border-radius);
  cursor: pointer;
}

.error-message__dismiss {
  background: transparent;
  color: var(--sd-brown-dark);
  font-size: 1.5em;
  padding: 0;
  width: 24px;
  height: 24px;
}
```

### Loading State Management

```tsx
// src/hooks/useAsyncState.ts
interface AsyncState<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
}

export const useAsyncState = <T>(
  asyncFn: () => Promise<T>,
  deps: any[] = []
): AsyncState<T> & { refetch: () => void } => {
  const [state, setState] = useState<AsyncState<T>>({
    data: null,
    loading: true,
    error: null
  });

  const refetch = useCallback(async () => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const data = await asyncFn();
      setState({ data, loading: false, error: null });
    } catch (error) {
      setState({ 
        data: null, 
        loading: false, 
        error: error instanceof Error ? error : new Error('Unknown error')
      });
    }
  }, deps);

  useEffect(() => {
    refetch();
  }, [refetch]);

  return { ...state, refetch };
};
```

## Error Logging Standards

### Error Logging Service Integration

```tsx
// src/services/errorLogger.ts
interface ErrorContext {
  userId?: string;
  sessionId?: string;
  component?: string;
  action?: string;
  metadata?: Record<string, any>;
}

class ErrorLogger {
  private logError(error: Error, context: ErrorContext = {}) {
    const errorData = {
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      ...context
    };

    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.error('Error logged:', errorData);
    }

    // Send to error tracking service
    this.sendToService(errorData);
  }

  private async sendToService(errorData: any) {
    try {
      await fetch('/api/errors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(errorData)
      });
    } catch (e) {
      console.error('Failed to log error:', e);
    }
  }

  logUserError(error: Error, context: ErrorContext = {}) {
    this.logError(error, { ...context, severity: 'user' });
  }

  logSystemError(error: Error, context: ErrorContext = {}) {
    this.logError(error, { ...context, severity: 'system' });
  }

  logApiError(error: Error, context: ErrorContext = {}) {
    this.logError(error, { ...context, severity: 'api' });
  }
}

export const errorLogger = new ErrorLogger();
```

### Error Context Capture

```tsx
// src/hooks/useErrorLogger.ts
export const useErrorLogger = (component: string) => {
  const logError = useCallback((error: Error, action?: string, metadata?: Record<string, any>) => {
    errorLogger.logUserError(error, {
      component,
      action,
      metadata: {
        ...metadata,
        timestamp: Date.now()
      }
    });
  }, [component]);

  return { logError };
};
```

## Error Recovery Patterns

### Retry Mechanisms

```tsx
// src/hooks/useRetry.ts
interface RetryOptions {
  maxAttempts?: number;
  delay?: number;
  backoff?: 'linear' | 'exponential';
}

export const useRetry = <T>(
  asyncFn: () => Promise<T>,
  options: RetryOptions = {}
) => {
  const { maxAttempts = 3, delay = 1000, backoff = 'exponential' } = options;
  const [attempts, setAttempts] = useState(0);
  const [isRetrying, setIsRetrying] = useState(false);

  const retry = useCallback(async (): Promise<T> => {
    setIsRetrying(true);
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        setAttempts(attempt);
        const result = await asyncFn();
        setIsRetrying(false);
        return result;
      } catch (error) {
        if (attempt === maxAttempts) {
          setIsRetrying(false);
          throw error;
        }
        
        const waitTime = backoff === 'exponential' 
          ? delay * Math.pow(2, attempt - 1)
          : delay * attempt;
        
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
    
    throw new Error('Max retry attempts exceeded');
  }, [asyncFn, maxAttempts, delay, backoff]);

  return { retry, attempts, isRetrying };
};
```

### Fallback Data Handling

```tsx
// src/hooks/useFallbackData.ts
export const useFallbackData = <T>(
  primaryData: T | null,
  fallbackData: T,
  isLoading: boolean,
  hasError: boolean
): T => {
  if (isLoading) {
    return fallbackData;
  }
  
  if (hasError && !primaryData) {
    return fallbackData;
  }
  
  return primaryData || fallbackData;
};

// Usage example
const userProfile = useFallbackData(
  userData,
  { name: 'Guest User', avatar: '/default-avatar.png' },
  isLoading,
  hasError
);
```

### Graceful Degradation

```tsx
// src/components/GracefulFeature.tsx
interface GracefulFeatureProps {
  children: ReactNode;
  fallback: ReactNode;
  isEnabled: boolean;
  error?: Error;
}

export const GracefulFeature: React.FC<GracefulFeatureProps> = ({
  children,
  fallback,
  isEnabled,
  error
}) => {
  if (!isEnabled || error) {
    return <>{fallback}</>;
  }
  
  return <>{children}</>;
};

// Usage
<GracefulFeature
  isEnabled={featureFlags.advancedSearch}
  error={searchError}
  fallback={<BasicSearch />}
>
  <AdvancedSearch />
</GracefulFeature>
```

## API Error Handling

### HTTP Error Handling

```tsx
// src/api/errorHandler.ts
export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public code?: string,
    public details?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export const handleApiError = (error: any): ApiError => {
  if (error.response) {
    // Server responded with error status
    const { status, data } = error.response;
    return new ApiError(
      data.message || `HTTP ${status} Error`,
      status,
      data.code,
      data.details
    );
  } else if (error.request) {
    // Network error
    return new ApiError(
      'Network error - please check your connection',
      0,
      'NETWORK_ERROR'
    );
  } else {
    // Other error
    return new ApiError(
      error.message || 'An unexpected error occurred',
      500,
      'UNKNOWN_ERROR'
    );
  }
};
```

### Network Error Handling

```tsx
// src/hooks/useApiCall.ts
export const useApiCall = <T>(
  apiCall: () => Promise<T>,
  options: { retries?: number; timeout?: number } = {}
) => {
  const [state, setState] = useState<{
    data: T | null;
    loading: boolean;
    error: ApiError | null;
  }>({
    data: null,
    loading: false,
    error: null
  });

  const execute = useCallback(async () => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const data = await apiCall();
      setState({ data, loading: false, error: null });
      return data;
    } catch (error) {
      const apiError = handleApiError(error);
      setState({ data: null, loading: false, error: apiError });
      throw apiError;
    }
  }, [apiCall]);

  return { ...state, execute };
};
```

### Timeout Handling

```tsx
// src/utils/timeout.ts
export const withTimeout = <T>(
  promise: Promise<T>,
  timeoutMs: number
): Promise<T> => {
  return Promise.race([
    promise,
    new Promise<never>((_, reject) =>
      setTimeout(() => reject(new Error('Request timeout')), timeoutMs)
    )
  ]);
};

// Usage
const data = await withTimeout(
  fetch('/api/data').then(res => res.json()),
  5000 // 5 second timeout
);
```

## Form Error Handling

### Field-Level Error Display

```tsx
// src/components/FormField.tsx
interface FormFieldProps {
  label: string;
  error?: string;
  required?: boolean;
  children: ReactNode;
}

export const FormField: React.FC<FormFieldProps> = ({
  label,
  error,
  required,
  children
}) => {
  const fieldId = useId();
  const errorId = `${fieldId}-error`;

  return (
    <div className="form-field">
      <label htmlFor={fieldId} className="form-field__label">
        {label}
        {required && <span className="form-field__required">*</span>}
      </label>
      <div className="form-field__input">
        {children}
      </div>
      {error && (
        <div 
          id={errorId}
          className="form-field__error"
          role="alert"
          aria-live="polite"
        >
          {error}
        </div>
      )}
    </div>
  );
};
```

### Form Submission Error Handling

```tsx
// src/hooks/useFormSubmission.ts
interface FormSubmissionState<T> {
  isSubmitting: boolean;
  submitError: string | null;
  isSuccess: boolean;
}

export const useFormSubmission = <T>(
  submitFn: (data: T) => Promise<void>
) => {
  const [state, setState] = useState<FormSubmissionState<T>>({
    isSubmitting: false,
    submitError: null,
    isSuccess: false
  });

  const submit = useCallback(async (data: T) => {
    setState({
      isSubmitting: true,
      submitError: null,
      isSuccess: false
    });

    try {
      await submitFn(data);
      setState({
        isSubmitting: false,
        submitError: null,
        isSuccess: true
      });
    } catch (error) {
      const errorMessage = error instanceof Error 
        ? error.message 
        : 'An error occurred while submitting the form';
      
      setState({
        isSubmitting: false,
        submitError: errorMessage,
        isSuccess: false
      });
    }
  }, [submitFn]);

  const reset = useCallback(() => {
    setState({
      isSubmitting: false,
      submitError: null,
      isSuccess: false
    });
  }, []);

  return { ...state, submit, reset };
};
```

### Validation Error Patterns

```tsx
// src/utils/formValidation.ts
interface ValidationResult {
  isValid: boolean;
  errors: Record<string, string>;
}

export const validateForm = <T>(
  data: T,
  rules: Record<keyof T, (value: any) => string | null>
): ValidationResult => {
  const errors: Record<string, string> = {};
  
  Object.entries(rules).forEach(([field, validator]) => {
    const error = validator(data[field as keyof T]);
    if (error) {
      errors[field] = error;
    }
  });

  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
};

// Usage
const validationRules = {
  email: (value: string) => {
    if (!value) return 'Email is required';
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
      return 'Please enter a valid email address';
    }
    return null;
  },
  password: (value: string) => {
    if (!value) return 'Password is required';
    if (value.length < 8) return 'Password must be at least 8 characters';
    return null;
  }
};
```

### Error Clearing Patterns

```tsx
// src/hooks/useFormErrors.ts
export const useFormErrors = <T extends Record<string, any>>(
  initialData: T
) => {
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [data, setData] = useState<T>(initialData);

  const setFieldError = useCallback((field: keyof T, error: string) => {
    setErrors(prev => ({ ...prev, [field]: error }));
  }, []);

  const clearFieldError = useCallback((field: keyof T) => {
    setErrors(prev => {
      const newErrors = { ...prev };
      delete newErrors[field];
      return newErrors;
    });
  }, []);

  const clearAllErrors = useCallback(() => {
    setErrors({});
  }, []);

  const updateField = useCallback((field: keyof T, value: any) => {
    setData(prev => ({ ...prev, [field]: value }));
    // Clear error when user starts typing
    if (errors[field]) {
      clearFieldError(field);
    }
  }, [errors, clearFieldError]);

  return {
    data,
    errors,
    setFieldError,
    clearFieldError,
    clearAllErrors,
    updateField
  };
};
```

## Implementation Rules

1. **Always wrap async operations** in try-catch blocks
2. **Provide fallback UI** for all error states
3. **Log errors with context** for debugging
4. **Test error paths** in unit and integration tests
5. **Use error boundaries** to prevent app crashes
6. **Provide retry mechanisms** for transient failures
7. **Clear errors** when user takes corrective action
8. **Use consistent error styling** across the application
9. **Implement graceful degradation** for non-critical features
10. **Validate all user inputs** before processing

## Testing Error Handling

```tsx
// Example test for error handling
describe('Error Handling', () => {
  it('displays error message when API call fails', async () => {
    const mockApiCall = jest.fn().mockRejectedValue(new Error('API Error'));
    
    render(<ComponentThatUsesApi apiCall={mockApiCall} />);
    
    await waitFor(() => {
      expect(screen.getByText('API Error')).toBeInTheDocument();
    });
  });

  it('allows retry after error', async () => {
    const mockApiCall = jest.fn()
      .mockRejectedValueOnce(new Error('Network Error'))
      .mockResolvedValueOnce({ data: 'success' });
    
    render(<ComponentWithRetry apiCall={mockApiCall} />);
    
    await waitFor(() => {
      expect(screen.getByText('Network Error')).toBeInTheDocument();
    });
    
    fireEvent.click(screen.getByText('Try Again'));
    
    await waitFor(() => {
      expect(screen.getByText('success')).toBeInTheDocument();
    });
  });
});
```
---
description: Enforce TypeScript strict mode, type safety, and configuration standards
globs: ["**/*.{ts,tsx}", "tsconfig.json", "**/*.d.ts"]
alwaysApply: true
---

# TypeScript Configuration Standards

## Strict Mode Requirements

### Compiler Options
All TypeScript projects must use strict mode with these required options:

```json
{
  "compilerOptions": {
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true
  }
}
```

### Type Safety Enforcement
- **No `any` type usage** - Use `unknown` or proper typing instead
- **No implicit any** - All parameters and variables must be explicitly typed
- **Strict null checks** - Handle null/undefined cases explicitly
- **No unused variables** - Remove or prefix with underscore (`_unusedVar`)

## Type Definition Patterns

### Interface vs Type Usage
- **Use interfaces** for object shapes and component props:
  ```typescript
  interface UserProfile {
    id: string;
    name: string;
    email: string;
  }
  
  interface ButtonProps {
    variant: 'primary' | 'secondary';
    onClick: () => void;
    children: React.ReactNode;
  }
  ```

- **Use types** for unions, computed types, and primitive aliases:
  ```typescript
  type Status = 'loading' | 'success' | 'error';
  type UserId = string;
  type ApiResponse<T> = {
    data: T;
    status: number;
  };
  ```

### Generic Type Patterns
- **Use generic constraints** for type safety:
  ```typescript
  interface ApiEndpoint<T extends Record<string, unknown>> {
    url: string;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE';
    data?: T;
  }
  
  function createApiCall<T extends { id: string }>(endpoint: ApiEndpoint<T>) {
    // T is constrained to have an id property
  }
  ```

- **Export component prop types** for reusability:
  ```typescript
  export interface FormStepProps {
    formData: FormData;
    updateFormData: (updates: Partial<FormData>) => void;
    onNext: () => void;
    onPrev: () => void;
  }
  ```

### Utility Type Usage
Prefer built-in utility types for common patterns:
- `Partial<T>` for optional updates
- `Pick<T, K>` for selecting specific properties
- `Omit<T, K>` for excluding properties
- `Record<K, V>` for key-value mappings

## Project Setup Standards

### Path Mapping Configuration
Use consistent path aliases in `tsconfig.json`:
```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/components/*": ["src/components/*"],
      "@/pages/*": ["src/pages/*"],
      "@/types/*": ["src/types/*"],
      "@/utils/*": ["src/utils/*"],
      "@/hooks/*": ["src/hooks/*"],
      "@/api/*": ["src/api/*"],
      "@/constants/*": ["src/constants/*"],
      "@/assets/*": ["src/assets/*"]
    }
  }
}
```

### Type Declaration Files
- **Global types**: Place in `src/types/` directory
- **Component types**: Export from component files or colocate in `types/`
- **API types**: Define in `src/api/` or `src/types/api.ts`
- **Form types**: Centralize in `src/types/formTypes.ts`

### Import/Export Patterns
- **Use absolute imports** with path aliases:
  ```typescript
  import { Button } from '@/components/Button';
  import { FormData } from '@/types/formTypes';
  import { validateEmail } from '@/utils/validation';
  ```

- **Export types explicitly**:
  ```typescript
  export type { UserProfile, ApiResponse };
  export interface { ButtonProps };
  ```

## Common TypeScript Patterns

### API Response Typing
```typescript
interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

interface ApiError {
  error: string;
  code: number;
  details?: Record<string, unknown>;
}

// Usage
const fetchUser = async (id: string): Promise<ApiResponse<UserProfile>> => {
  // Implementation
};
```

### Form Data Interfaces
```typescript
interface FormData {
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  // Use union types for constrained values
  packageType: "small" | "medium" | "large" | "xl" | "by-dozen" | "";
  // Use boolean for flags
  termsAccepted: boolean;
  // Use Set for collections
  visitedSteps: Set<string>;
}
```

### Error Handling Types
```typescript
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

// Usage
const processData = async (input: string): Promise<Result<ProcessedData>> => {
  try {
    const data = await process(input);
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error as Error };
  }
};
```

### Component Prop Exports
Always export component prop types for reusability:
```typescript
export interface ButtonProps {
  variant: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  onClick: () => void;
  children: React.ReactNode;
}

export const Button: React.FC<ButtonProps> = ({ variant, size = 'medium', ...props }) => {
  // Implementation
};
```

## Type Safety Best Practices

### Runtime Validation
Combine TypeScript with runtime validation:
```typescript
import { z } from 'zod';

const UserSchema = z.object({
  id: z.string(),
  name: z.string().min(1),
  email: z.string().email(),
});

type User = z.infer<typeof UserSchema>;

const validateUser = (data: unknown): User => {
  return UserSchema.parse(data);
};
```

### Event Handler Typing
Use proper event types for React handlers:
```typescript
const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
  event.preventDefault();
  // Implementation
};

const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  const value = event.target.value;
  // Implementation
};
```

### Async Function Typing
Always type async functions and handle errors:
```typescript
const fetchUserData = async (userId: string): Promise<UserProfile | null> => {
  try {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error('Failed to fetch user:', error);
    return null;
  }
};
```

## Implementation Rules

1. **Strict mode enforcement**: All projects must use strict TypeScript configuration
2. **No any types**: Use proper typing or `unknown` instead of `any`
3. **Explicit exports**: Export all types and interfaces that may be reused
4. **Path aliases**: Use `@/` prefix for all internal imports
5. **Type colocation**: Keep types close to their usage when possible
6. **Runtime validation**: Combine TypeScript with runtime validation libraries
7. **Error handling**: Use proper error types and Result patterns
8. **Component props**: Always export component prop interfaces
9. **API typing**: Type all API responses and requests
10. **Form typing**: Use strict interfaces for form data structures

## Quality Gates

Before committing TypeScript code:
1. `yarn type-check` - TypeScript compilation passes
2. No `any` types in production code
3. All exports are properly typed
4. Error handling includes proper types
5. Component props are exported and documented
6. API responses are fully typed
7. Form data uses strict interfaces
8. All async functions have proper return types

## Exceptions

The only exceptions to strict typing:
- Third-party library type declarations (use `@types/*` packages)
- Legacy code migration (document with TODO comments)
- Test mocks (use `as unknown as Type` for complex mocks)

Document any other exceptions with a comment explaining why strict typing cannot be applied.